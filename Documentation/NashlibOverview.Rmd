---
title: "Overview of Nashlib and its Implementations"
author: 
   - John C Nash, retired professor, University of Ottawa
   - Peter Olsen, retired ??
date: "11/01/2021"
output: pdf_document
bibliography: nashlib.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
## ??require(bookdown) # language engine to display text??
```

# Abstract

The repository \url{https://github.com/pcolsen/Nash-Compact-Numerical-Methods}
is a collection of implementations of the algorithms from @jncnm79, which was 
written by one of us (JN) in the mid 1970s. The present collection originated with a query 
from the other author (PO) concerning a possible Python implementation based on the
Pascal codes in the second edition of the original book (@nlacatvn1060620). 

From email interchanges, the repository and the idea of gathering different 
implementations and ensuring workable example codes arose. We hope that these will
be useful in various ways:

- as a focus for comparison of programming languages and coding styles for numerical
computations
- as a source of didactic examples and exercises for students
- as a resource for workers needing to embed numerical computations within their
application programs.

# History

?? give a history of the codes

# Documentation of this project

Github allows for Markdown (\url{http://www.aaronsw.com/weblog/001189} and
\url{https://daringfireball.net/projects/markdown/}) files to be included in the file repository. 
We have used this for the `README.md` file and some other introductory or indexing
documentation. There is also a wiki associated with each project. We have NOT 
used the wiki in favour of including a `Documentation` directory within the 
file repository so that the documentation is carried along with any clone of
the repository or download as a Zip archive.

A relatively well-developed resource for documentation is the `knitr` set of tools
(@xie2013dynamic). vastly expanded within the RStudio computational ecosystem.
See \url{https://rstudio.com/products/rstudio/}. In particular, the **Rmarkdown**
flavour of the **markdown** markup language allows for LaTeX mathematical
expressions to be included inline, BibTeX references to be cited easily, and
code in a number of programming languages to be executed, with the results automatically
included in the report. Reports can be output in a variety of ways such as HTML,
PDF (our choice), or even as Microsoft Word documents.

Code is placed in `chunk` blocks that are delimited with three reverse single quotation
marks (\`) at the left hand margin. The first of these can (and should) be qualified
by various instructions and parameters inside curly braces {}. To display the 
text 

```{r plaintext1a, echo=TRUE, eval=FALSE}
some text to display
more text
yet more
```

we preface it with a line having the three back-quotes followed by 

```
{r plaintext1, echo=TRUE, eval=FALSE}
```

(It is very difficult to get any line with the codes to display verbatim.)
       
We finish the text block with a line of just three reverse single quotes in a row.
Though we seem to be trying to display an R code chunk, we effectively list the text.
Similarly following the three back-quotes with

```
{r code=xfun::read_utf8('../pascal/knitrExample.pas'), echo=TRUE, eval=FALSE}
```

will list the program `knitrExample.pas`. Note we still need to follow this with
a line having the three back-quotes. See the `NashlibOverview.Rmd` file which is
the source of the present document for details.

# Programming language issues in  Nashlib implementations

## Fortran

Fortran is one of the oldest so-called "high-level" programming languages. One of us
first used this language in 1966 (as Fortran II) on an IBM 1620 computer. Fortran
has gone through a number of revisions, but a lot of legacy code still runs easily, 
particularly in the Fortran 1977 dialect (possibly also so-called Fortran IV which 
is close to this). Especially is some special-purpose structures are avoided, we
can often run legacy Fortran using the `gfortran` compiler available for Linux and
likely some other platforms.

Note that Fortran indexes arrays from 1 (i.e., the first element is element 1). 
Moreover, the storage layout of multidimensional arrays is such that the first
index varies most rapidly. That is, conventional 2-dimensional matrices are
stored in memory in column order, top to bottom. This was important in early
programs, where a number of tricks were used to exploit the indexing and
storage for speed or code size. 

## BASIC

BASIC was developed in 1964 for the Dartmouth College Time Sharing System by John Kemeny
and Thomas Kurtz. One of us (JN) was Canadian representative at the meeting in 1983 that
agreed the ISO/IEC 6373:1984 "Data Processing—Programming Languages—Minimal BASIC". 
Unfortunately, BASIC has been plagued by a multitude of incompatible dialects, though
in the 1980s many BASIC interpreters and compilers would execute code that used all
but a few of the IBM/Microsoft GWBASIC dialect elements. Microsoft has released the
source code in 2020 at \url{https://github.com/microsoft/GW-BASIC}, but without any
build scripts. However, executables are available, though some claimed sources
may be malware. CAUTION! One of us has an old MS-DOS executable `GWBASIC.EXE` that
runs quite satisfactorily under the `DOSbox` emulation software available in Linux
repositories, but the infrastructure is awkward to use under `knitr` environment
used for this document.

For the purposes of the present effort, it seems that the Linux `bwbasic` (Bywater
BASIC) is close enough to the GWBAIC dialect to be usable, and is, moreover, usable
under `knitr` as illustrated below and elsewhare in this repository.

Typically BASIC indexes arrays from 1, but we make no comment on storage layout.

## Pascal

Pascal is another programming language that suffers from many dialects. In this case,
it is less from dialect variation in the language itself, but in the libraries of 
functions supporting the execution of programs. In specifying the language, 
@Wirth1971Pascal left these libraries undefined, leading to some considerable chaos
in the commands to read or write information to or from programs. Borland Turbo
Pascal gained sufficient marked dominance to create a *de facto* common dialect
that has been more or less copied by the Free Pascal initiative (@FreePascal1993).

## Python

- Issue of indexing arrays from 0. 
- Issue of numPy and sciPy infrastructure. 
- Issue of array indexing style. [i] [j] vs [i, j]


## R

Indexes from 1. Very high level. Good for reference implementations.

## Others

?? Do we want to consider C (possibly using the Fortran and using f2c as starter?)

# Running codes in different programming languages

This part of the Overview document is likely to evolve as we and other workers
apply our ideas to different computing platforms. We welcome input and collaboration.

Our principal objective is to be able to take a program in one of the selected
programming languages (or dialects) and have it execute correctly and produce
acceptable output. In the subsections below, we outline how we do this, possibly
with variations for different operating environments.

## Fortran

Rmarkdown is able to compiler Fortran subroutines and then call them from
R. We leave out the question of timing for which this simple example was
devised.

```{r compfort, engine='fortran', results='hide'}
C Fortran test
      subroutine fexp(n, x)
      double precision x
C  output
      integer n, i
C  input value
      do 10 i=1,n
         x=dexp(dcos(dsin(dble(float(i)))))
  10  continue
      return
      end
```

Now try running it from R. 

```{r testfort, collapse=TRUE}
res = .Fortran("fexp", n=100000L, x=0)
str(res)
```

What about complete programs? In this case we need to work through the operating
system. For JN this is a Linux Mint MATE distribution. 

The following is file `knitrExample.f`. It is in the directory `../fortran/` relative
to this documentation file (`NashlibOverview.Rmd`). See the source of this document
for the mechanism by which the Fortran code is read into our discussion text.
Note the spaces before `exfort` -- this is the name of the chunk, and NOT the
name of the `knitr` programming language engine. Here we want simply to include
a chunk of text which is echoed but not evaluated.

```{fortran code=xfun::read_utf8('../fortran/knitrExample.f'), echo=TRUE}
```

We run the code with a command line script (**bash** script). Note that we
would ideally like to time the execution, but timing commands tend to be 
very particular to the programming environment. To keep this document portable,
we will leave out the timing except for R.

```{bash scriptfor}
#!/bin/bash
gfortran ../fortran/knitrExample.f
./a.out
```

## BASIC

Our example code is similar to that for Fortran.

```{r code=xfun::read_utf8('../BASIC/knitrExample.BAS'), echo=TRUE, eval=FALSE}
```

And we run it with **bash**.  Note that our example above includes a line
`quit`. This is NOT general, but seems to be the way to exit from the **bwbasic**
interpreter chosen for Linux Mint 20 by the authors.

```{bash scriptbas}
#!/bin/bash
bwbasic ../BASIC/knitrExample.BAS
echo "done"
```

## Pascal

Our example code is once again similar to that for Fortran.

```{r code=xfun::read_utf8('../pascal/knitrExample.pas'), echo=TRUE, eval=FALSE}
```

And we run it with **bash** after compiling with **fpc**. 

```{bash scriptpas, eval=FALSE}
#!/bin/bash
fpc ../pascal/knitrExample.pas
./knitrExample
```


## Python

## R

## Others



# References