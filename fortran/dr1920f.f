C&&& A19-20X
C  TEST ALGS. 19 & 20  FUNCTION MINIMIZATION
C  J.C. NASH   JULY 1978, APRIL 1989
      INTEGER N,ND,NDC,I,J,LIMIT,NIN,NOUT,LIMIT2
      REAL B(4),STEP,VL,X(5,6),VLN,E
      LOGICAL NOCOM
      EXTERNAL WFUN
C  I/O CHANNELS
      NIN=5
      NOUT=6
      N=4
      ND=5
      NDC=6
   1  READ(NIN,901)STEP,LIMIT,LIMIT2
 901  FORMAT(F10.5,2I5)
      IF(STEP.EQ.0.0)STOP
      IF(LIMIT.LE.0)STOP
      WRITE(NOUT,951)STEP,LIMIT,LIMIT2
 951  FORMAT(' PROBLEM=WOOD4 STEPSIZE=',F15.10,'  LIMITS',2I5)
      READ(NIN,902)B
 902  FORMAT(4F10.5)
      WRITE(NOUT,953)
 953  FORMAT(' INITIAL POINT')
      WRITE(NOUT,952)B
 952  FORMAT(1H ,4F15.10)
C   Set 0 to NOUT for intermediate output
  10  CALL A19NM(N,B,X,ND,NDC,NOCOM,LIMIT,VL,WFUN,STEP,0)
      WRITE(NOUT,954)VL,LIMIT
 954  FORMAT(' CONV. TO',1PE16.8,' IN',I5)
      WRITE(NOUT,952)B
      WRITE(NOUT,955)
 955  FORMAT(' AXIAL SEARCH')
      LIMIT=LIMIT2
C  NOTE SQRT(EPS) FOR IBM USED * STEP
      E=2.0**(-10)*STEP
      CALL A20AS(N,B,WFUN,VL,VLN,E,LIMIT,NOUT)
      IF(VLN.GT.VL)GOTO 20
      WRITE(NOUT,956)
 956  FORMAT(' NEW STARTING POINT')
      WRITE(NOUT,952)B
      LIMIT=LIMIT2
      LIMIT2=0
      IF(LIMIT.GT.0)GOTO 10
  20  WRITE(NOUT,957)
 957  FORMAT(' FINISHED')
      WRITE(NOUT,958)
 958  FORMAT(' ')
      GOTO 1
      END
      SUBROUTINE A19NM(N,B,X,NX,NX2,NOCOM,IFN,VL,FUN,STEP,IPR)
C  ALGORITHM 19 NELDER-MEAD SIMPLEX FUNCTION MINIMIZATION
C  THIS VERSION MODIFIED 1989-04-25 IN ACCORD WITH ERRORS DISCOVERED SINCE
C  THE 1979 VERSION WAS RELEASED
C  J.C. NASH   JULY 1978, FEBRUARY 1980, APRIL 1989
C  N= NO. OF PARAMETERS
C  B= VECTOR CONTAINING STARTING POINT & RETURNING MINIMUM
C  X= WORKING ARRAY NX BY NX2
C  NX & NX2 ARE DIMENSIONS OF X.  NX.GE.(N+1), NX2.GE.(N+2)
C  NOCOM=LOGICAL FLAG SET .TRUE. IF INITIAL POINT INFEASIBLE OR STEP=0.0
C  IFN = LIMIT TO NO. OF FUNCTION EVALUATIONS (INPUT)
C      = FUNCTION EVALUATIONS USED (OUTPUT)
C  VL  = FUNCTION VALUE AT MINIMUM
C  FUN = NAME OF FUNCTION SUBROUTINE  P= FUN(N,B,NOCOM)
C  STEP= STEPSIZE FOR CONSTRUCTING INITIAL SIMPLEX
C  IPR = PRINTER CHANNEL.  PRINTING IF IPR.GT.0
C  STEP0
      LOGICAL NOCOM
      INTEGER N,NX,NX2,N1,N2,IFN,LIFN,H,L,C,IPR
C
      REAL B(N),X(NX,NX2),STEP,P,VL,SIZE,ALPHA,BETA,GAMMA,T,VH,SS,VNEXT
      C=N+2
      N1=N+1
      ALPHA=1.0
      BETA=0.5
      GAMMA=2.0
      LIFN=IFN
C  IBM VALUE
C&&&       BIG=R1MACH(2)
      BIG=1.0E+35
C  STEP 1
      NOCOM=.FALSE.
      P=FUN(N,B,NOCOM)
      IFN=1
C  PRECAUTION FOR NULL STEP
      IF(STEP.EQ.0.0)NOCOM=.TRUE.
      IF(NOCOM)RETURN
      IF(IPR.GT.0)WRITE(IPR,960)P
 960  FORMAT(' INITIAL FUNCTION VALUE=',1PE16.8)
C  STEP 2
      X(N1,1)=P
      DO 10 I=1,N
        X(I,1)=B(I)
  10  CONTINUE
      L=1
      SIZE=0.0
C  STEP 3
      DO 40 J=2,N1
C  STEP 4
        DO 20 I=1,N
          X(I,J)=B(I)
  20    CONTINUE
        T=STEP
C  STEP 5
  25    X(J-1,J)=B(J-1)+T
C  STEP 6
        IF(X(J-1,J).NE.B(J-1))GOTO 30
        T=10.0*T
        GOTO 25
C  STEP 7
  30    SIZE=SIZE+ABS(T)
C  STEP 8
  40  CONTINUE
C  STEP 9
  45  SS=SIZE
C  STEP 10
      DO 60 J=1,N1
C  STEP 11
        IF(J.EQ.L)GOTO 60
C  STEP 12
        DO 50 I=1,N
          B(I)=X(I,J)
  50    CONTINUE
      NOCOM=.FALSE.
        P=FUN(N,B,NOCOM)
        IF(NOCOM)P=BIG
        IFN=IFN+1
        X(N1,J)=P
C  STEP 13
  60  CONTINUE
C  STEP 14
  65  L=1
      H=1
C****       NEXT=1
      VL=X(N1,1)
      VH=VL
C  STEP 15
      DO 80 J=2,N1
C  STEP 16
        T=X(N1,J)
C  STEP 17
        IF(T.GE.VL)GOTO 70
        VL=T
        L=J
C  STEP 18
  70    IF(T.LT.VH)GOTO 80
C****         NEXT=H
        H=J
        VH=T
C  STEP 19
  80  CONTINUE
C  PRINTOUT
      IF(IPR.GT.0)WRITE(IPR,950)IFN,VL,VH
 950  FORMAT( 8H #EVALS=,I4,19H SIMPLEX LOW + HIGH,1P2E16.8)
      IF(IFN.GT.LIFN)GOTO 400
C  STEP 20
      IF(VL.EQ.VH)RETURN
C**** FOLLOWING STATEMENT IS NEW
      VNEXT=VL+BETA*(VH-VL)
C     THIS SETS THE FUNCTION VALUE AT THE 'NEXT TO HIGHEST POINT'
C     IN AN APPROXIMATE WAY WITHOUT THE NECESSITY OF SEARCHING
C     FOR THIS POINT ITSELF.
C  STEP 21
      DO 100 I=1,N
        T=-X(I,H)
        DO 90 J=1,N1
          T=T+X(I,J)
  90    CONTINUE
        X(I,C)=T/N
 100  CONTINUE
C  STEP 22
      DO 110 I=1,N
        B(I)=(1.0+ALPHA)*X(I,C)-ALPHA*X(I,H)
 110  CONTINUE
      NOCOM=.FALSE.
      P=FUN(N,B,NOCOM)
      IFN=IFN+1
      IF(NOCOM)P=BIG
C  STEP 23
      IF(P.LT.VL)GOTO 350
C  STEP 24
      IF(P.LT.VNEXT)GOTO 390
C  STEP 25
      IF(P.GE.VH)GOTO 270
C  STEP 26
      DO 265 I=1,N
        X(I,H)=B(I)
 265  CONTINUE
      X(N1,H)=P
C  STEP 27
 270  DO 275 I=1,N
        B(I)=(1.0-BETA)*X(I,H)+BETA*X(I,C)
 275  CONTINUE
      NOCOM=.FALSE.
      P=FUN(N,B,NOCOM)
      IFN=IFN+1
      IF(NOCOM)P=BIG
C  STEP 28
      IF(P.LT.X(N1,H))GOTO 390
C  STEP 29
      SIZE=0.0
      DO 320 J=1,N1
C  STEP 30
        IF(J.EQ.L)GOTO 320
C  STEP 31
        DO 310 I=1,N
          X(I,J)=BETA*(X(I,J)-X(I,L))+X(I,L)
          SIZE=SIZE+ABS(X(I,J)-X(I,L))
 310    CONTINUE
C  STEP 32
 320  CONTINUE
C  STEP 33
      IF(SIZE.LT.SS)GOTO 45
C  STEP 34
      GOTO 400
C  STEP 35
 350  DO 355 I=1,N
        T=GAMMA*B(I)+(1.0-GAMMA)*X(I,C)
        X(I,C)=B(I)
        B(I)=T
 355  CONTINUE
      X(N1,C)=P
C  STEP 36
      NOCOM=.FALSE.
      P=FUN(N,B,NOCOM)
      IFN=IFN+1
      IF(NOCOM)P=BIG
C  STEP 37
      IF(P.LT.X(N1,C))GOTO 390
C  STEP 38
      DO 385 I=1,N
        B(I)=X(I,C)
 385  CONTINUE
      P=X(N1,C)
C  STEP 39
 390  DO 395 I=1,N
        X(I,H)=B(I)
 395  CONTINUE
      X(N1,H)=P
      GOTO 65
C  STEP 40
 400  IF(L.EQ.0)NOCOM=.TRUE.
      IF(NOCOM)RETURN
      DO 410 I=1,N
        B(I)=X(I,L)
 410  CONTINUE
      RETURN
      END
      SUBROUTINE A20AS(N,B,FUN,P0,P,E,COUNT,IPR)
C  ALGORITHM 20  AXIAL SEARCH
C  J.C. NASH   JULY 1978, FEBRUARY 1980, APRIL 1989
C  N = ORDER OF PROBLEM = NO. OF PARAMETERS TO BE VARIED
C  B = SUPPOSED MINIMUM
C  FUN = NAME OF FUNCTION ROUTINE =   P=FUN(N,B,NOCOM)
C    WHERE NOCOM SET .TRUE. IF POINT IS INFEASIBLE
C  P0  = SUPPOSED MINIMAL FN VALUE
C  P   =  OUTPUT FUNCTION VALUE.  P.LT.P0 IF SEARCH SUCCESSFUL
C      IN SUCH A CASE  P=FUN(N,B,NOCOM)  I.E. B IS LEFT ALTERED
C  E   = NUMBER.GT.0.0 USED TO COMPUTE INCREMENT AT STEP 3
C  COUNT = NUMBER OF EVALUATIONS MADE (OUTPUT ONLY)
C  IPR =  PRINT CHANNEL.  NO PRINTING UNLESS IPR.GT.0
C  STEP 0
      LOGICAL NOCOM
      INTEGER COUNT,N,IPR,I
      REAL B(N),P0,P,T,S,E,BIG
C  IBM VALUE FOR BIG - A LARGE NUMBER USED TO GIVE A VALUE TO P
C     WHEN POINT IS NOT FEASIBLE
C&&&       BIG=R1MACH(2)
      BIG=1.0E+35
      IF(IPR.GT.0)WRITE(IPR,950)P0
 950  FORMAT(34H AXIAL SEARCH - SUPPOSED MINIMUM =,1PE16.8,3H AT)
      IF(IPR.GT.0)WRITE(IPR,951)(I,B(I),I=1,N)
 951  FORMAT( 3H B(,I3,2H)=,1PE16.8)
      COUNT=0
C  SAFETY CHECK
      IF(E.LE.0.0)STOP
C  STEP 1
      DO 90 I=1,N
C  STEP 2
        T=B(I)
C  STEP 3
        S=E*(ABS(T)+E)
C  STEP 4
        B(I)=T+S
        NOCOM=.FALSE.
        P=FUN(N,B,NOCOM)
        COUNT=COUNT+1
        IF(NOCOM)P=BIG
        IF(IPR.GT.0)WRITE(IPR,952)I,B(I),P
 952    FORMAT( 3H B(,I3,2H)=,1PE16.8,10H FN VALUE=,E16.8)
C  STEP 5
        IF(P.LT.P0)RETURN
C  STEP 6
        B(I)=T-S
        NOCOM=.FALSE.
        P=FUN(N,B,NOCOM)
        COUNT=COUNT+1
        IF(NOCOM)P=BIG
C  STEP 7
      IF(IPR.GT.0)WRITE(IPR,952)I,B(I),P
        IF(P.LT.P0)RETURN
C  STEP 8
        B(I)=T
C  STEP 9
  90  CONTINUE
      RETURN
      END
      FUNCTION WFUN(N,B,NOCOM)
C  J.C. NASH   JULY 1978, APRIL 1989
      LOGICAL NOCOM
      INTEGER N
      REAL B(N),FV,D(4)
      IF(N.NE.4)STOP
      NOCOM=.FALSE.
      CALL WOOD4(FV,D,B,0,.FALSE.)
      WFUN=FV
      RETURN
      END
      SUBROUTINE WDER(N,B,G)
C  J.C. NASH   JULY 1978, APRIL 1989
      INTEGER N
      REAL B(N),G(4),FV
      IF(N.NE.4)STOP
      CALL WOOD4(FV,G,B,0,.TRUE.)
      RETURN
      END
      SUBROUTINE WOOD4(FVAL,D,X,I,MODE)
C  J.C. NASH   JULY 1978, APRIL 1989
C  WOOD'S 4 PARAMETER FUNCTION
C  FVAL  =  FUNCTION VALUE OR RESIDUAL VALUE AT POINT I
C   D    =  DERIVATIVES OF RESIDUAL I
C   X    =  POINT
C   I    =  OBSERVATION NO.  IF 0  THEN  COMPUTE SUM OF SQUARES OR GRAD
C  MODE  =  F  FN OR  RES, T  DERIVS. OR GRADIENT
      LOGICAL MODE
      INTEGER I
      REAL X(4),D(4)
C  HILLSTROM EXPRESSIONS
      IF(MODE) GOTO 500
      IF(I.GT.0)GOTO 250
C   SUM OF SQUARES TOTAL FN
      FVAL=100.0*(X(2)-X(1)**2)**2 + (1.0-X(1))**2
      FVAL=FVAL + 90.0*(X(4)-X(3)**2)**2
      FVAL=FVAL + (1.0-X(3))**2
      FVAL=FVAL + 10.1*((X(2)-1.0)**2 + (X(4)-1.0)**2)
      FVAL=FVAL + 19.8*(X(2)-1.0)*(X(4)-1.0)
      RETURN
C   RESIDUALS
 250  GOTO (310,320,330,340,350,360,370),I
 310  FVAL=10.0*(X(2)-X(1)**2)
      RETURN
 320  FVAL=1.0-X(1)
      RETURN
 330  FVAL=SQRT(90.0)*(X(4)-X(3)**2)
      RETURN
 340  FVAL=1.0-X(3)
      RETURN
 350  FVAL=SQRT(0.2)*(X(2)-1.0)
      RETURN
 360  FVAL=SQRT(0.2)*(X(4)-1.0)
      RETURN
 370  FVAL=SQRT(9.9)*(X(2)+X(4)-2.0)
      RETURN
C    DERIVATIVES
 500  IF(I.GT.0)GOTO 750
C   GRADIENT OF FN
      D(1)=-400.0*(X(2)-X(1)**2)*X(1) - 2.0*(1.0-X(1))
      D(2)= 200.0*(X(2)-X(1)**2) + 20.2*(X(2)-1.0) + 19.8*(X(4)-1.0)
      D(3)=-360.0*X(3)*(X(4)-X(3)**2) - 2.0*(1.0-X(3))
      D(4)= 180.0*(X(4)-X(3)**2) + 20.2*(X(4)-1.0) + 19.8*(X(2)-1.0)
      RETURN
C   RESIDUAL DERIVS AT OBSN I
 750  GOTO (810,820,830,840,850,860,870), I
 810  D(1)= -20.0*X(1)
      D(2)= 10.0
      D(3)=  0.0
      D(4)=  0.0
      RETURN
 820  D(1)= -1.0
      D(2)=  0.0
      D(3)=  0.0
      D(4)=  0.0
      RETURN
 830  D(1)=  0.0
      D(2)=  0.0
      D(3)= -2.0*SQRT(90.0)*X(3)
      D(4)=  SQRT(90.0)
      RETURN
 840  D(1)= 0.0
      D(2)=  0.0
      D(3)= -1.0
      D(4)=  0.0
      RETURN
 850  D(1)=  0.0
      D(2)= SQRT(0.2)
      D(3)=  0.0
      D(4)=  0.0
      RETURN
 860  D(1)=  0.0
      D(2)=  0.0
      D(3)=  0.0
      D(4)= SQRT(0.2)
      RETURN
 870  D(1)=  0.0
      D(2)= SQRT(9.9)
      D(3)=  0.0
      D(4)= SQRT(9.9)
      RETURN
      END
C&&&   0.1      1000  100
C&&&  -3.0      -1.0      -3.0      -1.0
C&&&   1.0      1000  100
C&&&  -3.0      -1.0      -3.0      -1.0
C&&&   0.1       100   10
C&&&  -3.0      -1.0      -3.0      -1.0
C&&&   0.001    1000  100
C&&&  -3.0      -1.0      -3.0      -1.0
C&&&   0.0         0    0
